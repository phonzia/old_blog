---
layout: post
title: Linux 之 守护进程
---
&emsp; &emsp;因为新系统用的开源驱动的问题，主板温度一直处于可以煮鸡蛋的状态，这个绝不夸张，用conky监测一下，基本都是维持在九十多度左右，真是怀念用chakra的时候闭源驱动那凉快的感觉，既然是主板温度过高，基本只有两种可能了，一个是CPU温度过高，另一个就是显卡温度过高，看了一下，我的CPU利用率还在可以接受范围的过程之内，那就差不多是显卡温度惹得祸了，我查了一下，开源驱动默认情况下是最大性能模式，这就好办了，只要我在开机的时候把显卡运作频率降低就可以了，这个就要用到我题目中说的守护进程了。守护进程就是在linux中后台执行的电脑程序，这类程序会以进程的方式初始化，在ubuntu等linux操作系统中，只需要把相应命令写进rc.local即可，你可以理解成开机的时候会读取这个文件进行进程的初始化，但是在fedora15,arch等操作系统中，这种方式已经不合适了，因为这几个操作系统现在都引入了一个叫systemd 的东东。这个东西可以理解成linux下的一个初始化软件其开发目标是提供更优秀的框架以表示系统服务间的依赖关系，并依此实现系统初始化时服务的并行启动，同时达到降低Shell的系统开销的效果，最终代替现在常用的System V与BSD风格init程序。简单来说，这个东西可以提高相互依赖的各项服务的并行运行性能。所以我们可以自己编写一个服务，这个服务里面放上我们自己想运行的进程或者命令，然后通过systemd控制他的运行即可。参照archwiki上面systemd的语法我们就能很容易的写出一个服务文件出来。

    [Unit]
    Description=Myself

    [Service]
    Type=oneshot
    ExecStart=/home/kiwee/bin/myself
    RemainAfterExit=yes

    [Install]
    WantedBy=multi-user.target

&emsp; &emsp;语法我就不分析了，而且看英文自己也能理解，myself就是我自己写的那个要开机运行的守护进程，我们把他cp到/usr/lib/systemd/system/下，这样，我们就可以用sudo systemctl start myself.service用来开启这个服务，要让它开机运行，只要sudo systemctl enable myself.service即可，这句话其实就是创建了一个软链接，把ln -s '/usr/lib/systemd/system/myself.service' '/etc/systemd/system/multi-user.target.wants/myself.service',这里面放的就是开机要运行的服务了。这儿有个要注意的地方，我按照上面这么改之后，每次开机的时候都会出现Cannot add dependency myself.service~ to multi-user.target, ignoring: Invalid argument,我查了两天最后才发现我曾经修改过
/etc/systemd/system/multi-user.target.wants/下的myself.service，这样在这个目录下产生了一个无法识别的备份文件。。。导致开机的时候无法识别，所以，如果要修改服务文件，还是在/usr/lib/systemd/system/下修改，就省了我这两天功夫了- -。开机运行降频的守护进程之后，主板总算变得很凉快了。。。   
<p></p>

&emsp; &emsp;生命不息，折腾不止。
