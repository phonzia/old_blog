---
title: C++中的段错误（三）——printf
layout: post
categories: ''
tags: ''
---
# 问题

printf/sprinf 一类与字符串格式化相关的 C 语言风格函数即使在 c++ 中也常有应用. 也有很多日志库也以类似的风格设计，于是就出现一个问题，如果在格式化中，原本应该是一个字符串的地方放置了一个整形，或者是一个整形的位置放置了一个字符串，会出现什么情况。比如以下例子：

{% highlight cpp linenos %}
#include<stdio.h>

int main(int argc, char *argv[]) {
    int i; //不赋值，表示 i 可以为任意整形数
    printf("%s", i);

    return 0;
}
{% endhighlight %}

# 解说

类似问题中的例子，出现的行为是不确定的，因为 i 会被强制转型为一个 char* 来解释，随着 i 的值的不同，行为会有所不同.

* 如果 i 所指向地址可以访问，则打印该地址解释为字符串之后的内容。当然，也有可能地址可以访问，但是无法解释为 c 风格的字符串，也可能产生段错误。
* 如果 i 指向地址不可访问，则产生段错误。

除了以字符串形式去解释整形，printf 还可能出现其他错误：

1. 以整形解释字符串，应该出现 %s 的地方出现了 %d (或者其他整形的格式符).
2. 误用了不同长度的整形的描述符，该用 %ld 的地方使用了 %d，或者相反.
3. 格式符和参数数量不匹配。

对于头两种情况，准确的说法，行为都是不确定的，也可能出现段错误，但是大部分时候出现的是打印错误，因为访问到不可访问的内存的可能性较低. 对最后一种情况，如果是格式符多的话，出现段错误可能性就很大了，反过来倒是没什么问题，但也是一种错误。

# 总结

不管怎样，printf 一类函数误用格式符都是非常危险的。利用编译器的警告可以检查出这种问题，只要不偷懒，这一类问题还是相当容易避免的。如果是自己封装的类似的函数，gcc也有相应的扩展可以检查到(可以搜索 "__attribute__ format" ）.